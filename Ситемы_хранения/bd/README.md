# Домашнее задание "`Базы данных, их типы`" - `Прыкин Сергей`

### Задание 1 СУБД
Приведите ответ в свободной форме

### 1.1. Бюджетирование проектов, финансовая отчётность, прогнозирование рисков

Тип СУБД: Реляционная СУБД (SQL).
Почему: Ключевые требования — гарантированная целостность данных и чёткая структура. 
Реляционные СУБД (например, PostgreSQL, Microsoft SQL Server, Oracle Database) идеально подходят для этого, так как:
Используют ACID-транзакции, что обеспечивает точность и согласованность финансовых данных.
Имеют жёсткую схему данных, которая предотвращает попадание некорректной информации.
Мощный язык SQL позволяет выполнять сложные агрегации, соединения (JOIN) нескольких таблиц и строить детализированные отчёты.

#### 1.1. Хеширование стало занимать длительное время, какое API можно использовать для ускорения работы?*

Решение: Проблема с хешированием (скорее всего, используется для проверки паролей или целостности данных) говорит о высокой нагрузке. 
Вместо того чтобы нагружать основную СУБД, эту задачу стоит вынести в специализированное сервисное API.
Рекомендуемое API: Можно создать собственное микросервисное API на быстром языке (например, Go или Rust), 
которое будет заниматься исключительно хешированием. Если говорить о готовых облачных решениях, 
то многие платформы (как AWS, Google Cloud, Azure) предоставляют API для Key Management Services (KMS) и криптографических операций, 
которые аппаратно оптимизированы и выполняют такие операции крайне быстро.

### 1.2. Лендинги и CRM для управления лидами

Тип СУБД:
Для лендингов: Документоориентированная NoSQL СУБД (например, MongoDB). Почему: данные с форм захвата имеют простую,
но часто вариативную структуру. NoSQL позволяет гибко добавлять новые поля без изменения схемы, что обеспечивает высокую скорость записи.
Для CRM: Реляционная СУБД (SQL) (например, PostgreSQL). Почему: CRM — это ядро взаимодействия с клиентом, 
где важны связи (клиент -> сделки -> коммуникации), целостность данных и сложные аналитические запросы.

#### 1.2. Можно ли эту задачу закрыть одной СУБД?*

Да, можно. Универсальным решением, которое хорошо справится с обеими подзадачами, является PostgreSQL.
Реализация:
Для лендингов можно использовать тип данных JSONB. Он позволяет хранить данные лидов в виде гибких JSON-документов, 
обеспечивая при этом возможность индексации и достаточно быстрых запросов. Это даёт необходимую гибкость.
Для CRM использовать классические реляционные таблицы со строгой схемой.
Данные из JSONB-полей (лендинги) можно с помощью триггеров или ETL-процессов переносить и структурировать в основных таблицах CRM.

### 1.3. База корпоративных знаний, норм и правил

Тип СУБД: Графовая СУБД или Реляционная СУБД.
Почему: Требование "сформированную согласно структуре компании" — ключевое.
Графовая СУБД: Идеальна, если нужно отобразить иерархию отделов, связи между документами, теги и сложные цепочки "от родительского документа к дочерним". 
Позволяет очень наглядно моделировать и запрашивать связанные данные.
Реляционная СУБД: Также хорошо подходит, если структура знаний жёстко иерархична (дерево). Можно организовать через таблицы с самоссылающимися связями. 
Это проще в реализации и поддержке, если команда уже знакома с SQL.

#### 1.3. Можно ли под эту задачу использовать уже существующую СУБД?*

Да, безусловно. Целесообразно использовать ту же реляционную СУБД (например, PostgreSQL).
Реализация: Создать в рамках основной базы данных отдельную схему (schema) company_knowledge. 
В ней разместить таблицы: departments (отделы), documents (документы с полем document_id для иерархии), categories (категории знаний). 
Это обеспечит консолидацию данных, упростит администрирование и позволит строить отчёты, связывающие, к примеру, обучающие материалы и проекты.

### 1.4. Логистика: маршруты доставки и распределение курьеров

Тип СУБД: Графовая СУБД.
Почему: Прямое требование — "быстро работать со связями". Задача маршрутизации — это классическая задача теории графов.
Запросы на поиск оптимального маршрута выполняются в них на порядки быстрее, чем в SQL.

#### 1.4. Можно ли к этой СУБД подключить отдел закупок?*

Непосредственно "подключить" к графовой СУБД — не лучшая идея. Данные закупок (номенклатура, поставщики, цены, объёмы) — это типичные реляционные данные.
Решение — связка СУБД:
Основные данные по закупкам хранить в реляционной СУБД (той же PostgreSQL).
Графовая СУБД используется как мощный вычислительный движок для логистики.
Реализовать интеграцию между ними: приложение для логистики запрашивает из реляционной БД список объектов и необходимых материалов, а затем использует графовую БД
для построения оптимальных маршрутов их доставки. Отдел закупок, в свою очередь, может видеть рассчитанные логистами оптимальные точки поставки.

### 1.5. Можно ли все перечисленные выше задачи решить, используя одну СУБД?*
Технически — ДА. Мощная современная реляционная СУБД, такая как PostgreSQL.

 Как это реализовать в PostgreSQL:
  Финансы: Классические реляционные таблицы.
  Лендинги: Таблицы с полями типа JSONB для гибкого хранения данных лидов.
  CRM: Классические реляционные таблицы, связанные с данными лидов.
  База знаний: Отдельная схема с таблицами, организованными в иерархию.
  Логистика: Это самое слабое место, но и здесь можно использовать расширение pgRouting, которое добавляет в PostgreSQL функциональность для работы с графами и маршрутизации.
  Для средних по сложности задач его часто бывает достаточно.  
  
 Использование единой СУБД (PostgreSQL) — это хорошее и консервативное решение, которое минимизирует сложность администрирования, обеспечивает консистентность данных и позволяет  
 использовать мощный SQL для кросс-доменной аналитики.  
 Однако, для максимальной производительности и использования лучших свойств каждой модели данных в условиях очень высоких нагрузок, предпочтительнее гибридный подход:  
 Основная СУБД (SQL): PostgreSQL для финансов, CRM, базы знаний и данных закупок.  
 Специализированные СУБД:  
  MongoDB — для быстрого сбора данных с лендингов (если нагрузка очень высока).  
  Neo4j — для сложных задач логистической маршрутизации.
---

### Задание 2 Транзакции
Приведите ответ в свободной форме.

#### 2.1
Все действия происходят в рамках одной транзакции в реляционной СУБД (PostgreSQL).

1. Начало транзакции.
Приложение отправляет команду BEGIN TRANSACTION.
Система создаёт "снимок" данных на момент начала операции,
чтобы обеспечить изоляцию от других параллельных операций.

2. Проверка баланса плательщика.
Приложение выполняет запрос SELECT balance ...... FOR UPDATE;.
Фраза FOR UPDATE блокирует запись от изменения другими транзакциями, предотвращая "двойное списание".

3. Списание суммы пополнения со счёта плательщика.
Выполняется запрос UPDATE accounts.
Система проверяет, что после этого баланс не станет отрицательным (если это не разрешено условиями).

4. Зачисление суммы на счёт телефона.
Выполняется запрос UPDATE phone.
Система также может создать запись в таблице transactions для аудита.

5. Фиксация транзакции (Commit).
Если все предыдущие шаги выполнились без ошибок (денег хватает, номер корректен, связь стабильна), приложение отправляет команду COMMIT;.
В этот момент все изменения (шаги 3 и 4) окончательно и атомарно записываются в базу данных. Баланс обновляется у всех участников одновременно.

6. Подтверждение успеха пользователю.
После успешного COMMIT приложение получает подтверждение от СУБД и отображает пользователю сообщение: "Баланс успешно пополнен на 'сумма'".

#### 2.1*

Автоплатёж добавляет уровень сложности, так как включает планировщик заданий (scheduler) и дополнительную логику для обработки ошибок. 
Действия становятся асинхронными.

1. Запуск процесса по расписанию.
Планировщик заданий (например, cron или встроенный в СУБД pg_cron) в заданное время запускает процедуру обработки автоплатежей.

2. Выборка всех активных автоплатежей.
Выполняется запрос для получения списка всех подписок/автоплатежей, у которых наступила дата списания.

3. Обработка каждого автоплатёжа в отдельной транзакции.
Для каждого найденного автоплатёжа запускается цикл, и внутри него выполняются шаги, аналогичные стандартному пополнению (шаги 1-5 из предыдущего списка), но с важными дополнениями:*
Шаг 3 (Списание): Если денег на счету плательщика недостаточно, транзакция для этого конкретного автоплатёжа откатывается (ROLLBACK).
Шаг 5 (Фиксация): Если списание и зачисление прошли успешно, транзакция фиксируется.

4. Обновление данных автоплатёжа.
В рамках успешной транзакции (после шага 4, до шага 5 из первого списка) выполняется запрос, который обновляет дату следующего списания.

5. Обработка неудачных попыток.
Если транзакция не удалась (например, из-за недостатка средств), система обновляет статус автоплатёжа, чтобы прекратить повторные попытки или уведомить пользователя. 
Это действие также происходит в своей отдельной транзакции.

6. Логирование результата и уведомление.
После обработки всего списка система формирует отчёт или отправляет уведомления.
Пользователю может прийти SMS/email: "Автоплатёж на номер телефона выполнен успешно" или "Не удалось выполнить автоплатёж. Проверьте баланс вашей карты".
---

### Задание 3 SQL vs NoSQL

#### 3.1
1. Гарантированная целостность данных (ACID).
Это главное преимущество. Реляционные СУБД обеспечивают атомарность, согласованность, изоляцию и долговечность транзакций. 
Это критически важно для финансовых операций, банковских систем и любых приложений, где ошибка в данных стоит очень дорого. 
NoSQL-системы часто жертвуют полной ACID-совместимостью (особенно в распределённых сценариях) в пользу масштабируемости и доступности.

2. Универсальный и мощный язык запросов (SQL).
SQL — это стандартизированный, декларативный и невероятно мощный язык. 
Он позволяет выполнять сложные запросы с соединениями многих таблиц (JOIN), агрегациями, подзапросами и оконными функциями. 
С его помощью можно извлечь практически любую аналитику из данных. В NoSQL каждая система имеет свой собственный, зачастую более ограниченный, язык или API для запросов.

3. Жёсткая, заранее определённая схема данных.
Это не недостаток, а преимущество для многих задач. 
Схема заставляет тщательно продумывать структуру данных, их типы и связи ещё на этапе проектирования. 
Это предотвращает попадание в базу мусорных или некорректных данных, что повышает их качество и надёжность. 
В документоориентированных NoSQL-базах гибкая схема может привести к хаосу и проблемам с целостностью на уровне приложения.

4. Снижение избыточности данных (нормализация).
Реляционная модель поощряет нормализацию — процесс, устраняющий дублирование данных. 
Это позволяет хранить информацию в одном месте и ссылаться на неё. 
Например, данные о клиенте хранятся в одной таблице clients, а его заказы — в orders, что исключает необходимость 
многократного сохранения имени и адреса клиента для каждого заказа. Во многих NoSQL-подходах (особенно документоориентированных) данные 
часто денормализуются и дублируются для скорости чтения.

5. Зрелость, стабильность и экосистема.
SQL-системы (PostgreSQL, MySQL, Oracle) существуют десятилетиями. 
Они тщательно протестированы, обладают огромным сообществом, обширной документацией, 
множеством инструментов для администрирования, мониторинга, 
бэкапа и интеграции с любыми системами отчетности и BI (Business Intelligence).

#### 3.1*

NewSQL (например, Google Spanner, CockroachDB, VoltDB) — это попытка взять лучшее из обоих миров. Их ключевые преимущества:

1. Горизонтальная масштабируемость + ACID-транзакции.
Проблема SQL: Традиционные SQL-системы сложно масштабировать горизонтально (добавлением новых серверов). Кластерные решения часто требуют компромиссов.
Проблема NoSQL: Легко масштабируются, но часто жертвуют полной поддержкой ACID (особенно строгой изоляцией) или отказываются от JOIN.
Решение NewSQL: Они используют распределённые архитектуры (как NoSQL), но при этом поддерживают распределённые ACID-транзакции с сильной согласованностью (как SQL). 
Это позволяет приложению работать в глобальном масштабе, не теряя гарантий целостности данных.

2. Высокая производительность для OLTP-нагрузки.
NewSQL-системы часто спроектированы с нуля для работы в памяти (in-memory) или с использованием современных распределённых алгоритмов, 
что позволяет обрабатывать огромное количество коротких транзакций в секунду, превосходя по производительности традиционные SQL-системы, работающие с диском.

3. Более простая архитектура для глобальных приложений.
Для масштабирования традиционной SQL-системы часто приходится прибегать к шардингу (ручному разделению данных), что ложится сложной задачей на разработчиков. 
NewSQL-системы автоматизируют шардинг и репликацию, предоставляя приложению единое логическое представление базы данных, даже если она физически разбросана по 
десяткам серверов по всему миру.

4. Совместимость с SQL.
В отличие от NoSQL, большинство NewSQL-систем поддерживает знакомый SQL-синтаксис (или его большую часть). 
Это значительно снижает порог входа для разработчиков и позволяет использовать существующие инструменты и знания, 
в отличие от изучения новых языков запросов для каждого типа NoSQL.
---

### Задание 4 Кластеры

### Модель распределённых вычислений
Для работы с огромным количеством данных на 1000 машинах лучше всего справится модель MapReduce и её современные реализации и альтернативы.
Масштабируемость: Модель MapReduce была разработана именно для такого сценария. Она позволяет разбить любую задачу на две фазы:
Map (Отображение): Большая задача разбивается на множество мелких подзадач, которые распределяются по всем узлам кластера (вплоть до 1000 машин). 
Каждая машина обрабатывает свою часть данных независимо и параллельно.
Reduce (Свёртка): Результаты работы всех Map-задач агрегируются и объединяются в финальный результат.
Эта модель идеально ложится на кластер из 1000 машин, так как позволяет задействовать все вычислительные ресурсы одновременно.
Отказоустойчивость: Системы, реализующие MapReduce (например, Apache Hadoop), автоматически перезапускают упавшие задачи на других работоспособных узлах кластера. 
При таком количестве машин отказы оборудования — это не ЧП, а обычная рабочая ситуация, и модель MapReduce справляется с этим "из коробки".
Локальность данных: Вычисления переносятся к данным, а не наоборот. Это критически важно при больших объёмах данных. 
Вместо того чтобы перекачивать петабайты информации по сети, код для обработки отправляется на те машины, где физически расположены данные, что радикально снижает сетевую нагрузку.

1. Если задача — сложные пакетные вычисления и ETL: Выбираем Apache Spark. Он отлично масштабируется на тысячи узлов, отказоустойчив и предоставляет богатейший 
набор библиотек для машинного обучения (MLlib), графовой обработки (GraphX) и работы с данными.

2. Если задача — аналитика и быстрые агрегирующие запросы по историческим данным: Выбираем колоночную OLAP-СУБД, например, ClickHouse.

3. Если задача — обработка данных в реальном времени: Выбираем Apache Flink.
